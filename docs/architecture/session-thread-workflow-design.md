# Session-Thread-Workflow 架构设计文档

## 设计理念

基于领域驱动设计（DDD）原则，采用清晰的层次分离和职责划分：

- Thread 专注于执行实例标识和生命周期管理
- Workflow 专注于业务逻辑定义和图结构管理
- Session 专注于多线程并行管理和资源协调
- WorkflowEngine 专注于工作流执行协调（应用层服务）

## 架构层次

系统采用四层架构，从上到下依次为：

接口层（Interface Layer）：提供外部接口适配，包括 HTTP API、gRPC、CLI 等。负责与外部系统集成和用户交互。

应用层（Application Layer）：提供应用服务和业务流程编排。包含 WorkflowEngine、StateManager、ConditionalRouter、HistoryManager 等服务。这些服务协调领域组件完成业务逻辑。

领域层（Domain Layer）：包含核心业务实体和值对象。包括 Workflow、Thread、CheckpointManager 等聚合根和实体。定义业务规则和领域概念。

基础设施层（Infrastructure Layer）：提供技术实现细节。包括 ExpressionEvaluator、NodeExecutor、数据库存储、外部 API 集成等。实现领域层定义的接口。

依赖关系遵循单向依赖原则：基础设施层依赖领域层，应用层依赖领域层，接口层依赖应用层。

## 职责分工

### Thread 职责（领域层聚合根）

Thread 作为执行实例的标识符，专注于生命周期管理和状态跟踪。

主要职责包括：

- 生命周期管理：启动、暂停、恢复、完成、失败、取消等状态转换
- 状态跟踪：维护线程状态（pending、running、paused、completed、failed、cancelled）
- 进度管理：跟踪执行进度和当前步骤
- 元数据管理：维护线程的标题、描述、优先级等元数据
- 执行上下文：持有执行上下文信息

Thread 不负责：

- 具体的工作流执行逻辑（由 WorkflowEngine 负责）
- 状态数据的日常更新（由 StateManager 负责）
- 检查点管理（由 CheckpointManager 负责）
- 执行历史记录（由 HistoryManager 负责）

### Workflow 职责（领域层聚合根）

Workflow 作为业务逻辑定义的聚合根，专注于图结构管理和业务逻辑定义。

主要职责包括：

- 图结构管理：节点和边的增删改查
- 业务逻辑定义：工作流名称、描述、类型、配置
- 图遍历支持：提供基本的图查询方法（获取入边、获取出边）
- 状态管理：工作流版本、时间戳、创建者等元数据
- 基本验证：简单的存在性检查和可执行性检查

Workflow 不负责：

- 复杂的图遍历算法（由应用层服务负责）
- 执行状态管理（由 Thread 和 StateManager 负责）
- 路由决策（由 ConditionalRouter 负责）
- 节点执行（由 NodeExecutor 负责）

### Session 职责（领域层聚合根）

Session 作为多线程管理器，专注于线程生命周期管理和资源协调。

主要职责包括：

- 线程生命周期管理：创建、销毁、fork 线程
- 资源协调：管理线程间的资源共享和隔离
- 并行策略：支持多种并行执行策略
- 线程间通信：协调线程间的数据交换

Session 不负责：

- 具体的工作流执行逻辑（由 WorkflowEngine 负责）
- 单线程内的状态管理（由 StateManager 负责）

### WorkflowEngine 职责（应用层服务）

WorkflowEngine 作为工作流执行协调者，是整个执行流程的核心协调者。

主要职责包括：

- 执行协调：协调工作流的完整执行流程
- 节点执行顺序：根据路由决策确定节点执行顺序
- 路由决策集成：调用 ConditionalRouter 进行路由决策
- 状态管理集成：调用 StateManager 管理执行状态
- 检查点管理：调用 CheckpointManager 创建和恢复检查点
- 执行控制：提供暂停、恢复、取消等执行控制功能
- 错误处理：处理节点执行错误和恢复逻辑

核心特性：

- 支持顺序执行和条件路由
- 支持检查点和恢复
- 支持执行超时和最大步数限制
- 支持错误处理和恢复
- 支持执行控制（暂停/恢复/取消）

### StateManager 职责（应用层服务）

StateManager 作为状态管理器，专注于工作流执行状态的管理。

主要职责包括：

- 状态初始化：初始化工作流执行状态
- 状态更新：提供不可变的状态更新
- 状态查询：获取当前状态和状态数据
- 状态历史：记录状态变更历史
- 状态验证：验证状态数据的有效性

核心特性：

- 不可变的状态更新
- 线程级别的状态隔离
- 状态变更历史记录
- 状态数据验证

StateManager 不负责：

- 状态快照和恢复（由 CheckpointManager 负责）
- 执行历史记录（由 HistoryManager 负责）

### ConditionalRouter 职责（应用层服务）

ConditionalRouter 作为路由决策器，专注于基于条件的路由决策。

主要职责包括：

- 路由决策：基于边的条件表达式进行路由决策
- 条件评估：使用 ExpressionEvaluator 评估条件表达式
- 路由历史：记录路由决策历史
- 决策日志：提供详细的决策日志

核心特性：

- 支持无条件边和条件边
- 支持默认边
- 支持多路分支路由
- 支持自定义上下文

### HistoryManager 职责（应用层服务）

HistoryManager 作为历史记录管理器，专注于执行历史的记录和查询。

主要职责包括：

- 执行历史记录：记录节点执行历史
- 历史查询：查询执行历史
- 历史统计：提供执行统计信息

核心特性：

- 线程级别的历史隔离
- 支持历史记录查询
- 支持历史统计

### CheckpointManager 职责（领域层服务）

CheckpointManager 作为检查点管理器，专注于检查点的生命周期管理。

主要职责包括：

- 检查点创建：创建执行检查点
- 检查点恢复：从检查点恢复执行状态
- 检查点管理：管理检查点的生命周期
- 过期清理：自动清理过期检查点

核心特性：

- 线程级别的检查点管理
- 支持检查点过期清理
- 使用 ThreadCheckpoint 实体

### ExpressionEvaluator 职责（基础设施层服务）

ExpressionEvaluator 作为表达式评估器，专注于表达式的评估和验证。

主要职责包括：

- 表达式评估：评估条件表达式
- 表达式验证：验证表达式语法
- 安全执行：提供安全的表达式执行环境

核心特性：

- 使用 Jexl 库，避免原型污染漏洞
- 支持复杂的条件表达式
- 支持表达式验证
- 支持表达式缓存
- 支持自定义转换器和函数

## 执行流程

### 正常执行流程

工作流正常执行的流程如下：

1. 创建 Thread 实例，标识执行实例
2. 调用 WorkflowEngine 的执行方法
3. StateManager 初始化执行状态
4. 查找工作流的起始节点
5. 进入执行循环：
   - 检查执行控制状态（暂停、恢复、取消）
   - NodeExecutor 执行当前节点
   - StateManager 更新执行状态
   - HistoryManager 记录执行历史
   - CheckpointManager 创建检查点（可选）
   - ConditionalRouter 进行路由决策，确定下一个节点
6. 返回执行结果

### 检查点恢复流程

从检查点恢复执行的流程如下：

1. 调用 WorkflowEngine 的恢复方法
2. CheckpointManager 恢复状态数据
3. StateManager 清除旧状态
4. StateManager 初始化新状态
5. 继续执行（从执行循环的第5步开始）

## 架构优势

### 1. 职责清晰

每个组件都有明确的职责边界：

- Thread 专注于执行实例标识和生命周期管理
- Workflow 专注于业务逻辑定义和图结构管理
- WorkflowEngine 专注于工作流执行协调
- StateManager 专注于状态管理
- ConditionalRouter 专注于路由决策
- CheckpointManager 专注于检查点管理
- HistoryManager 专注于历史记录
- ExpressionEvaluator 专注于表达式评估

这种职责分离使得每个组件都易于理解和维护。

### 2. 层次分明

系统采用清晰的四层架构：

- 领域层包含核心业务实体和值对象
- 应用层包含应用服务
- 基础设施层包含技术实现
- 接口层提供外部接口

层次依赖关系清晰，遵循单向依赖原则。

### 3. 可测试性强

- 每个组件都可以独立测试
- 依赖注入使得测试时可以轻松替换依赖
- 纯函数式的状态更新使得测试更加可靠

### 4. 可扩展性强

- 新增节点类型只需实现节点执行器接口
- 新增路由策略只需扩展条件路由器
- 新增状态存储方式只需扩展状态管理器
- 新增检查点存储方式只需扩展检查点管理器

### 5. 性能优化

- 表达式缓存减少重复计算
- 状态不可变性减少不必要的拷贝
- 检查点自动清理避免内存泄漏
- 路由历史限制避免无限增长

### 6. 安全性

- 使用 Jexl 库避免原型污染漏洞
- 表达式验证防止恶意代码执行
- 状态不可变性防止意外修改
- 执行超时和步数限制防止无限循环

### 7. 可观测性

- 详细的执行历史记录
- 路由决策日志
- 状态变更历史
- 检查点元数据

## 技术决策

### 1. 为什么使用 Jexl 而不是 expr-eval？

安全性考虑：Jexl 没有已知的安全漏洞，而 expr-eval 存在原型污染漏洞（GHSA-8gw3-rxh4-v6jx）。

TypeScript 支持：Jexl 是 TypeScript-first 的库，类型定义更完善。

性能考虑：Jexl 的性能与 expr-eval 相当，但更安全。

### 2. 为什么 StateManager 在应用层而不是领域层？

职责分离：StateManager 是应用服务，负责协调状态管理，不是领域概念。

灵活性：应用层服务可以更容易地替换实现。

依赖关系：StateManager 依赖 WorkflowState（领域层），符合依赖方向。

### 3. 为什么 CheckpointManager 在领域层？

领域概念：检查点是工作流执行的核心领域概念。

实体管理：CheckpointManager 管理 ThreadCheckpoint 实体。

业务规则：检查点的创建、恢复、清理都是业务规则。

### 4. 为什么 WorkflowEngine 在应用层？

协调职责：WorkflowEngine 是应用服务，负责协调多个领域组件。

无状态：WorkflowEngine 本身不维护状态，只是协调者。

可替换：应用层服务可以更容易地替换实现。

### 5. 为什么 Thread 不负责执行逻辑？

职责单一：Thread 是执行实例的标识符，不应该负责执行逻辑。

可复用性：执行逻辑应该独立于 Thread，可以被多个 Thread 复用。

可测试性：执行逻辑独立使得测试更加容易。

## 后续优化方向

### 1. 性能优化

- 实现状态缓存（LRU）
- 实现表达式预编译
- 实现批量检查点创建
- 添加性能测试

### 2. 功能增强

- 支持并行节点执行
- 支持子工作流调用
- 支持工作流版本管理
- 支持工作流可视化

### 3. 可靠性提升

- 实现数据库持久化
- 实现分布式执行
- 实现故障转移
- 实现重试机制

### 4. 可观测性增强

- 添加性能指标
- 添加分布式追踪
- 添加日志聚合
- 添加监控告警

## 总结

本架构设计基于领域驱动设计原则，采用清晰的层次分离和职责划分。Thread、Workflow、Session 作为领域层的核心聚合根，分别负责执行实例管理、业务逻辑定义和多线程管理。WorkflowEngine、StateManager、ConditionalRouter、HistoryManager 作为应用层服务，负责协调领域组件完成业务逻辑。CheckpointManager 和 ExpressionEvaluator 分别在领域层和基础设施层提供检查点管理和表达式评估功能。

这种架构设计具有职责清晰、层次分明、可测试性强、可扩展性强、性能优化、安全性高、可观测性好等优势。通过合理的技术决策和清晰的职责划分，系统具有良好的可维护性和可扩展性。