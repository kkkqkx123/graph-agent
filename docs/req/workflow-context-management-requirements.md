# 工作流上下文管理需求分析文档

## 1. 当前上下文管理机制分析

### 1.1 现有上下文管理组件

#### 1.1.1 提示词上下文 (PromptContext)
- **位置**: `src/domain/workflow/value-objects/context/`
- **职责**: 管理提示词模板、历史记录和元数据
- **现状**: 仅关注提示词层面，不包含工作流执行状态信息
- **问题**: 历史记录条目缺少统一的索引机制，无法区分不同类型的输入输出

#### 1.1.2 执行上下文 (ExecutionContext)
- **位置**: `src/domain/threads/value-objects/`
- **职责**: 管理线程执行过程中的变量和节点结果
- **现状**: 包含全局变量、节点结果和节点上下文
- **问题**: 属于threads域而非workflow域，缺乏对工作流执行状态的统一管理

#### 1.1.3 工作流状态 (ThreadWorkflowState)
- **位置**: `src/domain/threads/value-objects/`
- **职责**: 表示线程执行过程中的工作流状态
- **现状**: 包含工作流ID、当前节点ID、执行数据、历史记录和元数据
- **问题**: 属于threads域而非workflow域，执行数据字段过于笼统且缺乏结构化

#### 1.1.4 节点状态 (NodeStatus)
- **位置**: `src/domain/workflow/value-objects/node/`
- **职责**: 表示单个节点的执行状态
- **现状**: 包含pending、running、completed、failed、skipped、cancelled等状态值
- **问题**: 仅包含状态值，不包含详细的执行生命周期信息

### 1.2 现有上下文处理器

#### 1.2.1 上下文处理器架构
- **位置**: `src/services/workflow/functions/nodes/context-processors/`
- **现有处理器**: LLM上下文、工具上下文、人工上下文、系统上下文、透传、隔离、正则过滤等
- **现状**: 基于函数式编程范式，提供统一的处理器接口
- **问题**: 处理器之间缺乏统一的上下文对象，难以协同工作

### 1.3 当前架构的主要问题

#### 1.3.1 上下文信息分散
- 上下文信息分散在多个值对象中（PromptContext、ExecutionContext、ThreadWorkflowState）
- 难以统一管理和维护，增加系统复杂性

#### 1.3.2 域边界模糊
- ExecutionContext和ThreadWorkflowState属于threads域，但包含workflow执行信息
- 违反DDD分层原则，导致域间不必要的耦合

#### 1.3.3 缺乏统一索引机制
- 提示词历史记录缺少统一索引，无法追踪完整的输入输出流
- 难以实现精确的上下文追踪和调试

#### 1.3.4 类型安全性不足
- 节点结果存储为unknown类型，缺乏结构化定义
- 运行时类型错误风险较高，降低代码可维护性

#### 1.3.5 更新机制不一致
- 不同上下文使用不同的更新机制（直接赋值、immutable更新等）
- 增加学习成本，容易引入不一致的bug

## 2. 核心需求定义

### 2.1 统一上下文管理需求

#### 2.1.1 创建统一的工作流上下文
- **需求**: 在domain层的workflow目录下创建单独的上下文定义
- **目标**: 整合所有上下文信息到统一的WorkflowContext值对象
- **位置**: `src/domain/workflow/value-objects/context/`

#### 2.1.2 上下文职责定义
- 管理工作流执行状态上下文
- 管理提示词上下文
- 提供统一的访问接口
- 支持跨组件的上下文共享

### 2.2 工作流执行状态上下文需求

#### 2.2.1 节点执行状态追踪
- **需求**: 记录已执行节点及节点执行状态
- **信息范围**:
  - 节点ID和基本信息
  - 执行状态（pending、running、completed、failed等）
  - 执行时间信息（开始时间、结束时间、耗时）
  - 错误信息（如执行失败）
  - 执行结果元数据

#### 2.2.2 执行状态查询
- 支持按节点ID查询执行状态
- 支持按状态类型筛选节点
- 提供执行统计信息

### 2.3 提示词上下文增强需求

#### 2.3.1 完整的提示词上下文
- **需求**: 每个输入、输出都需要有索引，区分不同类型
- **条目类型**: 输入(input)、输出(output)、工具调用(tool_call)、工具结果(tool_result)
- **角色定义**: user、assistant、system、tool

#### 2.3.2 历史记录管理
- 支持完整的对话历史追踪
- 提供索引机制便于查询和回溯
- 支持基于索引的上下文截取和过滤

## 3. 功能需求定义

### 3.1 Append方式的更新接口

#### 3.1.1 核心需求
- **目标**: 让src/services/workflow目录的各个组件都能够以append方式更新状态上下文与提示词上下文
- **原则**: 不可变更新，每次更新返回新的上下文实例

#### 3.1.2 更新操作类型
- 追加节点执行状态
- 追加提示词历史记录
- 更新节点执行状态（基于节点ID）
- 更新全局变量
- 更新元数据

### 3.2 上下文处理器集成需求

#### 3.2.1 处理器访问统一上下文
- **需求**: 上下文处理器能够访问和更新统一的WorkflowContext
- **目标**: 所有处理器基于同一上下文对象工作，实现协同处理

#### 3.2.2 处理器链式执行
- 支持多个处理器按顺序执行
- 每个处理器基于前一个处理器的输出进行工作
- 保持上下文的完整性和一致性

### 3.3 状态快照和恢复需求

#### 3.3.1 状态快照
- 支持工作流执行状态的快照创建
- 快照包含完整的上下文信息
- 支持增量快照和全量快照

#### 3.3.2 状态恢复
- 从快照恢复工作流执行状态
- 支持断点续传功能
- 保证恢复后的状态一致性

### 3.4 查询和统计需求

#### 3.4.1 执行状态查询
- 按节点ID查询执行状态
- 按状态类型筛选节点
- 查询执行时间范围

#### 3.4.2 执行统计
- 统计总节点数、已执行节点数、成功节点数、失败节点数
- 统计执行耗时分布
- 统计错误类型分布

## 4. 非功能需求定义

### 4.1 性能需求

#### 4.1.1 响应时间
- 上下文更新操作应在10ms内完成
- 上下文查询操作应在5ms内完成
- 状态快照创建应在100ms内完成

#### 4.1.2 内存占用
- 单个工作流上下文内存占用不超过100MB
- 支持1000+并发工作流执行
- 内存使用应随执行节点数线性增长，而非指数增长

#### 4.1.3 吞吐量
- 支持每秒1000+次上下文更新操作
- 支持每秒5000+次上下文查询操作

### 4.2 可靠性需求

#### 4.2.1 数据一致性
- 保证上下文数据的一致性，避免数据竞争
- 支持并发访问的线程安全
- 更新操作应具有原子性

#### 4.2.2 错误恢复
- 支持执行失败时的状态恢复
- 提供错误上下文信息，便于问题定位
- 支持部分状态的恢复和重试

#### 4.2.3 日志记录
- 记录所有上下文变更操作
- 记录执行状态转换历史
- 支持日志级别配置

### 4.3 可维护性需求

#### 4.3.1 代码质量
- 遵循DDD分层原则，保持域边界清晰
- 使用TypeScript强类型，提高类型安全性
- 保持代码简洁，避免过度设计

#### 4.3.2 文档要求
- 提供完整的API文档
- 提供使用示例和最佳实践
- 提供架构设计文档

#### 4.3.3 测试要求
- 单元测试覆盖率不低于80%
- 提供集成测试用例
- 提供性能测试基准

### 4.4 扩展性需求

#### 4.4.1 功能扩展
- 支持自定义上下文字段的添加
- 支持自定义执行状态类型
- 支持自定义提示词历史条目类型

#### 4.4.2 集成扩展
- 支持与其他系统的上下文集成
- 支持上下文数据的导入导出
- 支持上下文格式的转换

## 5. 约束条件

### 5.1 技术约束
- 必须遵循现有项目的DDD分层架构
- 必须保持与现有系统的兼容性
- 必须使用TypeScript进行开发

### 5.2 设计约束
- 上下文定义必须放在domain层的workflow目录下
- 必须保持值对象的不可变性
- 必须使用依赖注入进行服务管理

### 5.3 兼容性约束
- 需要兼容现有的ExecutionContext和ThreadWorkflowState
- 需要提供迁移路径，支持逐步替换
- 需要保持现有API的稳定性
