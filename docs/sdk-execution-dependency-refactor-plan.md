# SDK Execution 模块依赖管理重构方案

## 修改目标

解决 sdk/core/execution 模块中的依赖管理问题，提高代码的可维护性、可测试性和扩展性。

## 核心问题与修改策略

### 1. 循环依赖问题（最高优先级）

**问题描述**：ThreadExecutor 与 ThreadCoordinator 之间存在双向依赖，ThreadCoordinator 在构造函数中直接依赖 ThreadExecutor 实例。

**修改方案**：
- 将 ThreadCoordinator 对 ThreadExecutor 的直接依赖改为事件驱动机制
- ThreadExecutor 在执行 Fork/Join 操作时，通过 EventManager 发布相应事件
- ThreadCoordinator 监听这些事件并执行协调逻辑
- 移除 ThreadCoordinator 构造函数中的 ThreadExecutor 参数

**实施步骤**：
1. 定义 ForkEvent 和 JoinEvent 事件类型
2. 在 ThreadExecutor 的 executeLoop 方法中，当遇到 FORK/JOIN 节点时，发布对应事件
3. 修改 ThreadCoordinator 的构造函数，移除 ThreadExecutor 参数
4. 在 ThreadCoordinator 中注册事件监听器
5. 更新 ThreadExecutor 的构造函数调用，不再传递 this 给 ThreadCoordinator

**预期效果**：彻底消除循环依赖，两个模块通过事件机制解耦。

### 2. 紧耦合问题（高优先级）

**问题描述**：ThreadExecutor、CheckpointManager 等核心类在构造函数中直接实例化多个依赖对象，导致紧耦合。

**修改方案**：
- 将所有内部 new 操作改为构造函数参数注入
- 创建 ExecutionModuleFactory 工厂类，集中管理复杂对象的创建逻辑
- 保持向后兼容，提供默认配置选项

**实施步骤**：
1. 重构 ThreadExecutor 构造函数，将所有内部 new 操作改为参数注入
2. 重构 CheckpointManager 构造函数，将所有内部 new 操作改为参数注入
3. 创建 ExecutionModuleFactory 类，封装复杂的对象创建逻辑
4. 在工厂类中管理共享实例（如 WorkflowRegistry、ThreadRegistry）
5. 更新所有使用这些类的地方，改为通过工厂创建或手动注入依赖

**预期效果**：模块间依赖关系清晰，便于单元测试和替换实现。

### 3. 重复实例化问题（中优先级）

**问题描述**：WorkflowRegistry 和 ThreadRegistry 在多个地方被独立实例化，可能导致状态不一致。

**修改方案**：
- 在应用入口创建共享的 Registry 实例
- 通过构造函数将这些共享实例传递给所有需要的地方
- 在工厂类中管理这些共享实例的生命周期

**实施步骤**：
1. 确定需要共享的 Registry 实例（WorkflowRegistry、ThreadRegistry）
2. 在应用初始化时创建这些共享实例
3. 修改所有需要这些 Registry 的类，通过构造函数接收
4. 更新工厂类，使用共享实例而不是创建新实例
5. 添加文档说明哪些实例应该是共享的

**预期效果**：确保关键组件的状态一致性，减少内存占用。

### 4. 依赖管理混乱问题（中优先级）

**问题描述**：依赖获取方式不统一，有的通过构造函数注入，有的内部实例化，有的使用可选参数+默认实例化。

**修改方案**：
- 制定统一的依赖管理规范
- 所有外部依赖必须通过构造函数注入
- 禁止使用内部 new 操作创建外部依赖
- 可选参数仅用于配置项，不用于依赖对象

**实施步骤**：
1. 制定依赖管理规范文档
2. 逐步重构现有代码，统一使用构造函数注入
3. 在代码审查中检查依赖管理规范的遵守情况
4. 为新代码编写单元测试，确保依赖可注入

**预期效果**：代码风格统一，降低维护成本，提高可测试性。

### 5. 缺乏依赖注入容器问题（低优先级）

**问题描述**：没有使用依赖注入容器，依赖关系需要手动管理。

**修改方案**：
- 评估引入轻量级依赖注入容器（如 tsyringe）
- 逐步迁移现有代码到 DI 容器
- 为所有核心服务定义接口，依赖接口而非实现

**实施步骤**：
1. 调研并选择合适的 DI 容器库
2. 在项目中引入 DI 容器，并进行基础配置
3. 为核心服务定义接口（如 IThreadExecutor、IThreadCoordinator）
4. 逐步将现有类注册到 DI 容器
5. 更新使用这些类的地方，改为从容器解析
6. 编写迁移指南和最佳实践文档

**预期效果**：自动管理依赖关系，支持高级特性（如作用域、拦截器），提高架构灵活性。

### 6. 静态工厂方法局限性问题（低优先级）

**问题描述**：NodeExecutorFactory 使用静态方法和静态 Map，难以扩展和测试。

**修改方案**：
- 将静态工厂改为实例工厂
- 工厂类通过构造函数接收配置和依赖
- 支持自定义执行器的注册和覆盖

**实施步骤**：
1. 重构 NodeExecutorFactory，将静态方法和属性改为实例成员
2. 修改构造函数，支持自定义执行器映射
3. 更新所有调用 NodeExecutorFactory 的地方，创建工厂实例
4. 在工厂类中支持依赖注入，便于执行器获取其他服务
5. 添加测试用例，验证工厂的可扩展性

**预期效果**：提高工厂类的灵活性和可测试性，支持自定义节点类型。

## 实施优先级与时间表

### 第一阶段（1-2周）：解决核心问题
- 解决循环依赖问题（P0）
- 解决紧耦合问题（P0）
- 解决重复实例化问题（P1）

### 第二阶段（3-4周）：统一规范
- 解决依赖管理混乱问题（P1）
- 完善工厂模式（P2）
- 编写单元测试

### 第三阶段（1-2月）：架构优化
- 引入依赖注入容器（P2）
- 定义服务接口
- 完善文档和最佳实践

## 风险评估与应对策略

### 高风险
- **修改过程中引入新 Bug**：每个重构步骤后运行完整的测试套件
- **循环依赖解决方案的复杂性**：先采用事件驱动方案，后续考虑 DI 容器

### 中风险
- **团队成员适应新规范**：进行代码审查和培训
- **性能影响**：重构后进行性能测试，确保没有显著下降

### 低风险
- **静态工厂改为实例工厂**：影响范围有限，易于回滚

## 成功标准

1. 所有循环依赖被消除
2. 核心类通过构造函数注入所有依赖
3. 关键组件（Registry）实现单例共享
4. 单元测试覆盖率达到 80% 以上
5. 代码审查中不再出现依赖管理问题
6. 新功能开发效率提升 30%

## 后续优化方向

1. 引入依赖注入容器，进一步简化依赖管理
2. 实现模块的热加载和插件化
3. 添加依赖关系可视化工具
4. 建立自动化的架构健康度检查
