# HumanRelay 概念澄清

## 概述

本文档澄清 HumanRelay 单轮模式和多轮模式的正确理解，以及它们的使用场景。

## 核心概念

### 单轮模式 (Single Mode)

**定义**：每次交互都提供完整的上下文（包括历史对话）

**特点**：
- 每次请求都包含所有历史消息
- 适用于外部LLM无法保持会话状态的情况
- 类似于"无状态"交互模式

**使用场景**：
- 使用无状态的Web LLM接口
- 每次都需要重新建立上下文的LLM服务
- 需要确保每次交互都有完整信息的场景

**实现方式**：
```typescript
// 单轮模式：合并所有消息和历史，提供完整上下文
const allMessages = history ? [...history, ...messages] : messages;
return allMessages
  .map(msg => `${msg.role}: ${msg.content}`)
  .join('\n');
```

### 多轮模式 (Multi Mode)

**定义**：每次交互只提供增量内容（新消息）

**特点**：
- 每次请求只包含新的消息
- 依赖于外部LLM能够保持会话状态
- 类似于"有状态"交互模式

**使用场景**：
- 使用有状态的LLM API（如ChatGPT、Claude等）
- LLM能够自动维护对话历史
- 需要减少每次传输数据量的场景

**实现方式**：
```typescript
// 多轮模式：只使用最新消息作为增量提示
const latestMessage = messages[messages.length - 1];
return `${latestMessage.role}: ${latestMessage.content}`;
```

## 常见误解

### 误解1：单轮模式 = 只能进行一次对话

**错误理解**：认为单轮模式只能进行一次对话，不能支持多轮交互。

**正确理解**：单轮模式同样可以支持多轮对话，只是每次都需要提供完整的上下文。用户可以进行多轮交互，但系统每次都会把所有历史内容发送给外部LLM。

### 误解2：多轮模式 = 系统需要管理历史

**错误理解**：认为多轮模式需要系统来管理和维护对话历史。

**正确理解**：多轮模式实际上依赖于外部LLM来维护对话历史，系统只需要发送新的消息内容。

## 前端实现建议

### 单轮模式的前端展示
- 应该显示完整的对话历史，让用户了解上下文
- 可以提供"复制全部"功能，方便用户将完整内容复制到外部LLM
- 界面应该明确提示用户需要输入完整上下文

### 多轮模式的前端展示
- 只需要显示最新的消息内容
- 可以提供简化的界面，专注于新消息的输入
- 界面应该提示用户LLM会保持之前的对话内容

## 配置建议

### 基础配置
两种模式都应该包含的基础配置：
- 模式标识（single/multi）
- 超时时间
- 历史长度限制（用于内部管理）

### 避免的配置
- 前端相关的配置（如show_history、prompt_style等）应该在前端实现中处理，而不是在配置文件中定义
- 模板定义应该在前端实现中处理，配置文件只需要定义模式相关的参数

## 总结

HumanRelay的两种模式设计是为了适应不同类型的外部LLM：
- **单轮模式**：适应无状态LLM，每次提供完整上下文
- **多轮模式**：适应有状态LLM，每次只提供增量内容

两种模式都支持多轮对话，区别在于如何处理和传递上下文信息。正确理解这两种模式的概念，有助于更好地设计和使用HumanRelay功能。