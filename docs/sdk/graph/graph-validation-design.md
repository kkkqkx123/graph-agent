# 图验证数据结构设计方案

## 设计目标
为工作流图验证提供高效、简洁的数据结构支持，专注于验证场景，避免过度设计。

## 核心数据结构

### 1. 邻接表结构
采用双向邻接表设计，包含两个核心映射：

- **正向邻接表**：记录每个节点的出边邻居节点列表
- **反向邻接表**：记录每个节点的入边邻居节点列表

这种设计支持：
- 快速遍历节点的所有出边（用于正向遍历）
- 快速遍历节点的所有入边（用于反向遍历）
- 高效构建，时间复杂度为O(V+E)

### 2. 节点映射表
建立节点ID到节点对象的映射关系，提供O(1)时间的节点查找能力。

### 3. 临时访问标记
在验证过程中使用临时集合记录访问状态：

- **已访问集合**：记录已遍历的节点，避免重复访问
- **递归栈集合**：用于环检测，记录当前递归路径上的节点
- **可达性集合**：记录从起点可达的节点或能到达终点的节点

这些标记在每次验证前创建，验证完成后立即释放，不占用长期内存。

## 数据结构构建流程

### 构建阶段
1. 初始化空的邻接表和节点映射表
2. 遍历所有节点，在邻接表中为每个节点创建空列表
3. 遍历所有边，填充正向和反向邻接表

### 验证阶段
1. 根据验证需求创建相应的访问标记集合
2. 执行具体的验证算法（环检测、可达性分析等）
3. 收集验证结果和错误信息
4. 清理临时标记集合

## 验证算法实现

### 环检测算法
采用深度优先搜索（DFS）配合递归栈标记：
- 从START节点开始遍历
- 访问节点时标记为"在递归栈中"
- 如果发现某个邻居节点已在递归栈中，则发现环
- 回溯时从递归栈中移除当前节点

### 可达性分析算法
采用广度优先搜索（BFS）或深度优先搜索（DFS）：
- 正向遍历：从START节点出发，标记所有可达节点
- 反向遍历：从END节点出发，在反向邻接表上标记所有能到达END的节点
- 比较两个结果集，找出不可达节点和死节点

### FORK/JOIN配对验证
基于节点映射表和邻接关系：
- 收集所有FORK节点和JOIN节点
- 检查FORK和JOIN的ID配对关系
- 验证FORK到JOIN之间的路径结构完整性

## 性能特征

### 时间复杂度
- 构建数据结构：O(V + E)
- 环检测：O(V + E)
- 可达性分析：O(V + E)
- 总体验证：O(k*(V + E))，其中k为验证项数量

### 空间复杂度
- 邻接表存储：O(V + E)
- 节点映射：O(V)
- 临时标记：O(V)
- 总体空间：O(V + E)

## 设计优势

1. **简洁性**：仅使用基础数据结构，易于理解和维护
2. **高效性**：线性时间复杂度，适合工作流验证场景
3. **低内存**：验证完成后立即释放临时结构
4. **可扩展**：支持添加新的验证算法而不改变基础结构
5. **无依赖**：不依赖外部库或复杂的数据结构库

## 适用场景

本设计专门针对以下场景优化：
- 工作流定义验证（部署前检查）
- 静态图结构分析
- 中等规模图（几十到几百个节点）
- 一次性验证任务

## 不适用场景

以下场景需要考虑更复杂的数据结构：
- 运行时动态图分析
- 超大规模图（数千节点以上）
- 需要频繁查询和更新的场景
- 实时性能要求极高的场景
