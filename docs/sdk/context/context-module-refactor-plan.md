# Context模块重构方案

## 问题概述

当前Context模块设计存在严重问题，需要进行系统性重构。主要问题包括职责不清、耦合度过高、单例模式滥用等，影响了代码的可维护性、可测试性和扩展性。

## 核心问题分析

### 1. ThreadContext职责过重

ThreadContext承担了过多职责，违反单一职责原则：
- 同时负责数据访问、状态管理、执行上下文等多重职责
- 直接依赖多个具体实现类（ConversationManager、VariableManager、GraphNavigator）
- 接口膨胀，暴露过多内部实现细节
- 包含执行相关的临时状态（如子图栈），应该与持久化数据分离

### 2. ExecutionContext设计问题

ExecutionContext作为依赖注入容器存在以下问题：
- 与ThreadContext名称相似但职责完全不同，容易造成混淆
- 强制使用单例模式，限制了多实例执行场景
- 硬编码的组件创建逻辑，缺乏灵活性
- 承担了依赖注入容器的职责，但实现不够完善

### 3. WorkflowContext功能冗余

WorkflowContext包含不必要的功能：
- 与GraphNavigator功能重叠，包含复杂的图遍历逻辑
- 职责不够聚焦，应该专注于只读数据访问
- 包含业务逻辑验证，应该由专门的验证器负责

### 4. 整体架构问题

- 执行状态管理、数据访问、依赖注入等关注点混杂
- 缺乏接口抽象，难以进行单元测试和扩展
- 依赖关系混乱，存在循环依赖风险

## 正确的职责定义

### WorkflowContext（工作流上下文）

**核心职责**：提供工作流定义的只读访问接口

**关键特性**：
- 不可变的工作流定义副本
- 高性能的节点和边查找
- 简单的图结构查询（入度、出度等）

**职责边界**：
- 不包含业务逻辑验证
- 不处理执行状态
- 不包含复杂的图遍历逻辑（应由GraphNavigator负责）

### ThreadContext（线程上下文）

**核心职责**：封装Thread实例的数据访问操作

**关键特性**：
- 统一的getter/setter接口
- 数据完整性保证
- 纯数据访问层

**职责边界**：
- 不包含执行逻辑
- 不管理执行状态
- 不直接依赖具体实现类（应通过接口抽象）

### ExecutionState（执行状态管理器）- 新增组件

**核心职责**：管理执行过程中的临时状态

**关键特性**：
- 子图栈管理
- 当前上下文切换
- 执行时变量管理

**职责边界**：
- 专注于执行时状态
- 与持久化数据分离
- 生命周期与执行周期绑定

### ExecutionContext（执行上下文容器）

**核心职责**：提供依赖注入和组件生命周期管理

**关键特性**：
- 支持多实例创建
- 可配置的组件初始化
- 测试友好的设计

**职责边界**：
- 容器职责，不包含业务逻辑
- 管理组件生命周期
- 提供依赖注入机制

## 单例vs多实例设计原则

### 应该保持单例的组件（全局共享资源）

**EventManager**
- 作为全局事件总线，需要所有组件共享同一事件通道
- 纯状态管理，只管理事件监听和分发
- 线程安全，无执行上下文依赖

**WorkflowRegistry**
- 工作流定义是全局共享资源
- 维护工作流注册、版本、预处理缓存等全局状态
- 所有执行实例需要访问相同注册表

**ThreadRegistry**
- 需要跟踪系统中所有活跃线程
- 提供全局线程管理和查询功能
- 作为线程生命周期的全局视图

### 应该支持多实例的组件（执行上下文相关）

**CheckpointManager**
- 需要支持不同的存储后端（内存、文件、数据库）
- 需要不同的检查点策略（定期、节点级别、手动）
- 测试时需要独立的存储实例

**ThreadLifecycleManager**
- 可能需要不同的生命周期事件处理策略
- 测试时需要独立的生命周期管理器
- 应通过构造函数注入EventManager

**ExecutionContext本身**
- 需要支持多个独立的执行环境
- 不同配置的执行上下文
- 并行测试环境

**ThreadContext**
- 每个线程执行都需要独立的上下文
- 状态隔离性要求
- 生命周期与执行周期绑定

**WorkflowContext**
- 可以支持多实例
- 不同的缓存策略
- 测试时的独立实例

## 重构方案

### 第一阶段：职责分离（高优先级）

**目标**：提取ExecutionState，分离ThreadContext的执行职责

**具体措施**：
1. 创建ExecutionState类，管理执行过程中的临时状态
2. 将ThreadContext中的子图栈管理、当前上下文切换等功能迁移到ExecutionState
3. ThreadContext专注于Thread数据的访问操作
4. 通过接口抽象解耦ThreadContext与具体实现类的依赖

**预期收益**：
- ThreadContext职责单一，符合单一职责原则
- 执行状态与持久化数据分离
- 提高代码的可测试性

### 第二阶段：接口抽象（中优先级）

**目标**：引入接口抽象，解耦具体实现依赖

**具体措施**：
1. 定义VariableAccess接口，隔离ThreadContext与VariableManager
2. 定义GraphAccess接口，隔离ThreadContext与GraphNavigator
3. 定义ConversationAccess接口，隔离ThreadContext与ConversationManager
4. 通过构造函数注入这些接口的实现

**预期收益**：
- 降低耦合度
- 便于单元测试（可以mock接口）
- 支持不同的实现策略

### 第三阶段：ExecutionContext重构（中优先级）

**目标**：重构ExecutionContext，移除单例模式

**具体措施**：
1. 移除模块级单例实例
2. 提供工厂方法createDefault()创建实例
3. 支持自定义配置的实例创建
4. 保留向后兼容的getDefault()方法（标记为deprecated）

**预期收益**：
- 支持多实例执行环境
- 提高灵活性
- 改善测试隔离性

### 第四阶段：WorkflowContext优化（低优先级）

**目标**：优化WorkflowContext，精简功能

**具体措施**：
1. 移除复杂的图遍历逻辑（如getOutgoingEdges的排序逻辑）
2. 将图遍历功能委托给GraphNavigator
3. 保持只读数据访问的核心职责
4. 考虑使用更高效的数据结构

**预期收益**：
- 职责更加聚焦
- 避免功能重复
- 提升性能

## 迁移策略

### 渐进式重构

1. **第一阶段**：提取ExecutionState，将执行相关逻辑从ThreadContext中分离
2. **第二阶段**：引入接口抽象，解耦具体实现依赖
3. **第三阶段**：重构ExecutionContext，移除单例模式
4. **第四阶段**：优化WorkflowContext，精简功能

### 向后兼容

- 保持现有API兼容性
- 提供适配器模式支持旧代码
- 逐步废弃不合理的API
- 提供清晰的迁移指南

## 预期收益

### 可维护性提升
- 每个组件职责单一，代码更清晰
- 职责边界明确，易于理解和维护
- 符合SOLID原则

### 可测试性增强
- 依赖通过接口注入，便于单元测试
- 支持多实例，测试隔离性更好
- 可以轻松mock依赖组件

### 扩展性改善
- 支持多实例执行，便于功能扩展
- 接口抽象支持不同的实现策略
- 配置灵活，适应不同场景

### 性能优化
- 职责分离后可以针对性优化各组件性能
- 减少不必要的依赖和耦合
- 支持缓存策略的灵活配置

## 总结

该重构方案将使context模块符合SDK的整体架构原则：
- 分离关注点
- 避免循环依赖
- 使用ID引用而非对象引用
- 保持依赖方向单向

通过系统性的重构，context模块将成为一个职责清晰、易于测试、便于扩展的高质量模块，为整个SDK提供坚实的基础。