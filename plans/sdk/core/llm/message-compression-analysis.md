# 消息压缩逻辑初步分析

## 概述

消息压缩是指当对话历史过长时，对消息进行压缩以减少Token使用量。本文档分析如何设计消息压缩逻辑。

## 设计原则

1. **事件驱动**：压缩逻辑不应该由Conversation自己管理，应该以事件的形式通知执行引擎
2. **上下文隔离**：压缩后应该创建全新的消息上下文实例，保证不会丢失旧的上下文
3. **可追溯性**：保留压缩前后的上下文关系，便于调试和审计

## 核心概念

### 1. 消息上下文（MessageContext）

消息上下文是对话历史的快照，包含：
- 消息数组
- Token统计信息
- 创建时间
- 父上下文引用（用于追溯）

### 2. 压缩事件（CompressionEvent）

当需要压缩时，触发压缩事件，包含：
- 当前上下文ID
- Token使用情况
- 压缩原因（超过限制、手动触发等）

### 3. 压缩工作流（CompressionWorkflow）

执行压缩的工作流，包含：
- 分析消息历史
- 生成压缩策略
- 执行压缩操作
- 创建新上下文

## 执行流程

### 步骤1：检测压缩需求

在每次LLM调用前，检查Token使用情况：

1. 从LLM API响应中获取Token统计（优先）
2. 如果API响应没有Token信息，使用本地计算器估算
3. 如果Token数量超过限制，触发压缩事件

### 步骤2：触发压缩事件

Conversation触发压缩事件：

1. 创建CompressionEvent
2. 包含当前上下文信息
3. 通过事件系统通知执行引擎

### 步骤3：执行引擎处理

执行引擎接收压缩事件：

1. 暂停当前执行
2. 调用压缩工作流
3. 等待压缩完成

### 步骤4：执行压缩工作流

压缩工作流执行压缩操作：

1. 分析消息历史
2. 识别可压缩的消息
3. 生成压缩策略
4. 执行压缩操作
5. 创建新上下文

### 步骤5：创建新上下文

压缩完成后，创建新的消息上下文：

1. 创建新的MessageContext实例
2. 设置父上下文引用为原上下文
3. 包含压缩后的消息数组
4. 保存压缩元数据

### 步骤6：恢复执行

执行引擎恢复执行：

1. 使用新上下文继续执行
2. 原上下文保留用于追溯

## 上下文管理

### 上下文链

每个上下文都保存父上下文引用，形成上下文链：

```
Context1 (初始)
  └─ Context2 (第一次压缩)
      └─ Context3 (第二次压缩)
```

### 上下文追溯

可以通过上下文链追溯完整的对话历史：

1. 从当前上下文开始
2. 递归查找父上下文
3. 合并所有上下文的消息
4. 重建完整的对话历史

### 上下文切换

在压缩时进行上下文切换：

1. 保存当前上下文
2. 创建新上下文
3. 更新Conversation使用新上下文
4. 原上下文保留用于追溯

## 压缩策略

### 策略1：保留最近消息

保留最近的N条消息，丢弃旧消息。

### 策略2：保留重要消息

保留系统消息、用户消息，丢弃助手消息和工具消息。

### 策略3：消息总结

对旧消息进行总结，生成摘要消息。

### 策略4：混合策略

结合多种策略，如保留系统消息和用户消息，对其他消息进行总结。

## Token统计

### 优先级

1. **API响应**：从LLM API响应中解析Token统计（最优先）
2. **本地计算**：使用tiktoken库进行本地计算（回退方案1）
3. **估算**：使用字符数除以2.5进行估算（回退方案2）

### API响应解析

从LLM API响应中提取Token信息：

```typescript
{
  usage: {
    prompt_tokens: 100,
    completion_tokens: 50,
    total_tokens: 150
  }
}
```

### 本地计算

使用tiktoken库进行本地计算：

1. 加载tiktoken编码器
2. 对消息进行编码
3. 计算Token数量

### 估算

使用字符数除以2.5进行估算：

```typescript
tokenCount = Math.ceil(text.length / 2.5)
```

## 事件定义

### CompressionRequestedEvent

请求压缩事件：

```typescript
{
  type: 'COMPRESSION_REQUESTED',
  contextId: string,
  tokenCount: number,
  tokenLimit: number,
  reason: string
}
```

### CompressionCompletedEvent

压缩完成事件：

```typescript
{
  type: 'COMPRESSION_COMPLETED',
  oldContextId: string,
  newContextId: string,
  compressedMessages: number,
  originalTokenCount: number,
  compressedTokenCount: number
}
```

### CompressionFailedEvent

压缩失败事件：

```typescript
{
  type: 'COMPRESSION_FAILED',
  contextId: string,
  error: string
}
```

## 实现建议

### 1. 在Conversation中

- 不实现压缩逻辑
- 只负责检测Token使用情况
- 触发压缩事件
- 接收新上下文并切换

### 2. 在执行引擎中

- 监听压缩事件
- 调用压缩工作流
- 管理上下文切换
- 恢复执行

### 3. 在压缩工作流中

- 实现压缩逻辑
- 创建新上下文
- 触发压缩完成事件

### 4. 在上下文管理器中

- 管理上下文生命周期
- 提供上下文追溯功能
- 管理上下文链

## 注意事项

1. **原子性**：压缩操作应该是原子的，要么全部成功，要么全部失败
2. **可回滚**：如果压缩失败，应该能够回滚到原上下文
3. **性能**：压缩操作不应该影响正常执行性能
4. **可配置**：压缩策略应该是可配置的
5. **可监控**：压缩操作应该有日志和监控

## 待解决问题

1. 如何定义压缩工作流？
2. 如何处理压缩过程中的错误？
3. 如何优化压缩性能？
4. 如何测试压缩逻辑？
5. 如何监控压缩效果？

## 总结

消息压缩逻辑应该采用事件驱动的方式，由执行引擎统一管理。压缩后创建新上下文，保留原上下文用于追溯。Token统计优先使用API响应，本地计算和估算作为回退方案。