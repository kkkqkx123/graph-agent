# message-serializer.ts - 消息序列化器逻辑设计

## 需求分析

消息序列化器需要提供以下核心能力：
1. 支持消息序列化
2. 支持消息反序列化
3. 处理特殊对象类型
4. 处理循环引用

这是一个轻量级的工具类，专注于消息的序列化和反序列化。

## 核心职责

1. 消息序列化
2. 消息反序列化
3. 特殊对象处理
4. 循环引用处理

## 主要方法逻辑

### 1. serializeMessage方法 - 序列化消息

将消息对象转换为可序列化的格式。

执行步骤：

步骤1：创建消息对象副本
- 使用JSON.parse(JSON.stringify(message))创建深拷贝
- 避免修改原始对象

步骤2：处理特殊对象
- 检查消息对象中是否有特殊对象（如Date、Map、Set等）
- 如果有Date对象，转换为ISO字符串
- 如果有Map对象，转换为普通对象
- 如果有Set对象，转换为数组

步骤3：处理循环引用
- 检查消息对象中是否有循环引用
- 如果有，使用占位符替换循环引用

步骤4：返回序列化后的对象
- 返回可序列化的对象

### 2. deserializeMessage方法 - 反序列化消息

将序列化的消息对象还原为消息对象。

执行步骤：

步骤1：接收序列化的消息对象
- 验证输入是否为对象
- 如果不是对象，抛出异常

步骤2：还原特殊对象
- 检查消息对象中是否有特殊格式的字符串
- 如果有ISO格式的日期字符串，转换为Date对象
- 如果有特殊格式的Map字符串，转换为Map对象
- 如果有特殊格式的Set字符串，转换为Set对象

步骤3：验证消息格式
- 调用validateMessage方法
- 验证消息格式是否正确
- 如果不正确，抛出异常

步骤4：返回消息对象
- 返回还原后的消息对象

### 3. serializeMessages方法 - 批量序列化消息

批量序列化消息数组。

执行步骤：

步骤1：遍历消息数组
- 对每条消息调用serializeMessage方法

步骤2：收集序列化结果
- 将序列化后的消息添加到结果数组

步骤3：返回结果数组
- 返回序列化后的消息数组

### 4. deserializeMessages方法 - 批量反序列化消息

批量反序列化消息数组。

执行步骤：

步骤1：遍历消息数组
- 对每条消息调用deserializeMessage方法

步骤2：收集反序列化结果
- 将反序列化后的消息添加到结果数组

步骤3：返回结果数组
- 返回反序列化后的消息数组

### 5. handleSpecialObjects方法 - 处理特殊对象

处理消息中的特殊对象类型。

执行步骤：

步骤1：检查对象类型
- 检查对象是否为Date
- 检查对象是否为Map
- 检查对象是否为Set
- 检查对象是否为其他特殊类型

步骤2：转换特殊对象
- 如果是Date，转换为ISO字符串
- 如果是Map，转换为普通对象
- 如果是Set，转换为数组
- 如果是其他特殊类型，转换为字符串

步骤3：返回转换后的对象
- 返回转换后的对象

### 6. restoreSpecialObjects方法 - 还原特殊对象

还原序列化后的特殊对象。

执行步骤：

步骤1：检查对象类型
- 检查对象是否为字符串
- 检查字符串格式是否匹配特殊对象格式

步骤2：还原特殊对象
- 如果是ISO日期字符串，转换为Date对象
- 如果是Map格式字符串，转换为Map对象
- 如果是Set格式字符串，转换为Set对象

步骤3：返回还原后的对象
- 返回还原后的对象

### 7. detectCircularReferences方法 - 检测循环引用

检测对象中的循环引用。

执行步骤：

步骤1：初始化检测栈
- 创建一个Set来存储已访问的对象

步骤2：递归检测
- 遍历对象的所有属性
- 如果属性值为对象，检查是否已访问
- 如果已访问，标记为循环引用
- 如果未访问，递归检测

步骤3：返回检测结果
- 返回是否包含循环引用

### 8. replaceCircularReferences方法 - 替换循环引用

替换对象中的循环引用。

执行步骤：

步骤1：初始化替换映射
- 创建一个Map来存储对象到占位符的映射

步骤2：递归替换
- 遍历对象的所有属性
- 如果属性值为对象且已访问，替换为占位符
- 如果未访问，递归替换

步骤3：返回替换后的对象
- 返回替换后的对象

## 错误处理

1. 序列化失败：捕获异常，返回null
2. 反序列化失败：捕获异常，抛出异常
3. 特殊对象处理失败：使用默认转换方法
4. 循环引用检测失败：跳过检测，继续处理

## 性能考虑

1. 深拷贝使用JSON方法，性能较好
2. 循环引用检测使用Set，查找效率高
3. 批量操作可以优化性能

## 扩展点

1. 自定义特殊对象处理
2. 自定义循环引用处理
3. 自定义序列化格式

## 使用场景

1. 在Conversation中使用：序列化消息历史
2. 在LLM节点中使用：序列化节点配置
3. 在应用层中使用：自定义序列化逻辑

## 注意事项

1. 序列化可能会丢失部分信息
2. 特殊对象处理需要谨慎
3. 循环引用处理可能会影响性能
4. 反序列化需要验证格式