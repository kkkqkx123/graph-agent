# 架构规范对比分析

## 架构规范要求回顾

根据 [`AGENTS.md`](AGENTS.md:1) 规范，Domain Layer 应遵循以下原则：

### 核心原则
1. **Domain Layer 不能依赖任何其他层**
2. **提供所有主要组件的契约**：LLM、存储、工作流、会话等
3. **只包含业务规则，不包含技术实现细节**
4. **所有领域定义必须集中在 `src/domain/` 目录**

### 目录结构规范
规范未明确指定统一的子目录结构，但强调：
- 领域定义集中化
- 基础设施隔离
- 单一事实来源

---

## 当前实现 vs 规范对比

### ❌ 违反规范的问题

#### 1. 仓储接口混合实现

**问题模块**：`llm`, `tools`

**违反点**：
```typescript
// src/domain/llm/repositories/llm-request-repository.ts
export interface LLMRequestRepository extends Repository<LLMRequest> {
  // 接口定义...
}

// src/domain/llm/repositories/llm-request-repository.interface.ts  
export interface ILLMRequestRepository {
  // 重复的接口定义...
}
```

**规范要求**：
- Domain Layer 只应包含接口契约
- 实现应在 Infrastructure Layer
- 不应有 `.interface.ts` 后缀文件

**影响**：
- 混淆了领域契约和技术实现
- 导致重复定义
- 增加维护成本

---

#### 2. 技术实现泄露到领域层

**问题模块**：`common`

**违反点**：
```typescript
// src/domain/common/utils/event-emitter.ts
export class EventEmitter {
  // 技术实现细节...
}

// src/domain/common/errors/error-handler.ts
export class DomainErrorHandler {
  // 错误处理策略实现...
}
```

**规范要求**：
- Domain Layer 只包含业务规则
- 技术基础设施应在 Infrastructure Layer

**影响**：
- 领域层承担了技术职责
- 违反了分层隔离原则
- 增加了领域层复杂度

---

#### 3. 接口定义位置不一致

**问题表现**：
- `llm/interfaces/` - 显式接口目录
- `tools/interfaces/` - 显式接口目录  
- `workflow/` - 接口混入其他目录
- 其他模块 - 无独立接口目录

**规范要求**：
- 接口是领域契约的一部分
- 应与相关实体/服务放在一起
- 不应单独隔离在 `interfaces/` 目录

**影响**：
- 接口发现困难
- 模块结构不统一
- 增加学习成本

---

#### 4. 子模块嵌套边界不清

**问题模块**：`threads/checkpoints`

**违反点**：
```
threads/
├── checkpoints/           # 子模块
│   ├── entities/
│   ├── repositories/
│   ├── services/
│   └── value-objects/
└── ...（标准结构）
```

**规范要求**：
- 领域边界应清晰
- 子领域应独立成模块

**影响**：
- 模块职责不清晰
- 可能违反单一职责原则
- 增加模块耦合度

---

### ⚠️ 部分符合规范的情况

#### 1. 通用值对象集中管理

**实现**：`common/value-objects/` 包含跨模块值对象

```typescript
// 通用ID类
export { ID } from './common/value-objects/id'
export { SessionId } from './common/value-objects/session-id'
export { ThreadId } from './common/value-objects/thread-id'
// ...
```

**评估**：
- ✅ 优点：避免重复定义，保持一致性
- ❌ 缺点：`common` 模块过于庞大
- ❌ 缺点：模块间隐含依赖

**建议**：
- 保持通用值对象在 `common`
- 但需明确界定"通用"标准
- 模块特定值对象应留在各自模块

---

#### 2. 事件定义方式

**实现**：部分模块有独立 `events/` 目录

```
sessions/events/
threads/events/
workflow/events/
```

**评估**：
- ✅ 符合领域驱动设计
- ✅ 事件作为领域契约的一部分
- ❌ 但缺乏统一规范

**建议**：
- 明确事件定义的必要性标准
- 统一事件目录命名和组织

---

### ✅ 符合规范的良好实践

#### 1. 实体定义清晰

**示例**：`workflow/entities/workflow.ts`

```typescript
export class Workflow extends Entity {
  private readonly props: WorkflowProps
  
  private constructor(props: WorkflowProps) {
    super(props.id, props.createdAt, props.updatedAt, props.version)
    this.props = Object.freeze(props)
  }
  
  // 业务方法...
}
```

**优点**：
- 符合领域实体定义规范
- 使用不可变属性
- 继承基础Entity类

---

#### 2. 值对象封装良好

**示例**：`workflow/value-objects/`

```typescript
export class WorkflowId extends ID {
  private constructor(value: string) {
    super(value, 'workflow')
  }
  
  static create(value: string): WorkflowId {
    // 验证逻辑...
    return new WorkflowId(value)
  }
}
```

**优点**：
- 封装验证逻辑
- 类型安全
- 不可变设计

---

#### 3. 领域服务职责明确

**示例**：`workflow/services/workflow-execution-service.ts`

```typescript
export class WorkflowExecutionService {
  constructor(
    private readonly workflowRepository: WorkflowRepository,
    private readonly stateManager: WorkflowStateManager
  ) {}
  
  async executeWorkflow(
    workflowId: WorkflowId,
    input: Record<string, unknown>
  ): Promise<ExecutionResult> {
    // 纯业务逻辑...
  }
}
```

**优点**：
- 只依赖领域接口
- 不包含技术实现
- 职责单一明确

---

## 规范符合度评分

| 模块 | 符合度 | 主要问题 | 严重程度 |
|------|--------|----------|----------|
| common | 60% | 技术实现泄露 | 高 |
| checkpoint | 90% | 无明显问题 | 低 |
| history | 90% | 无明显问题 | 低 |
| llm | 50% | 仓储混合、接口分离 | 高 |
| prompts | 85% | 结构不完整 | 中 |
| sessions | 90% | 无明显问题 | 低 |
| threads | 70% | 子模块嵌套 | 中 |
| tools | 55% | 仓储混合、接口分离 | 高 |
| workflow | 95% | 无明显问题 | 低 |

**整体符合度：73%**

---

## 规范违反的影响

### 短期影响
1. **代码理解困难**：不同模块结构差异大
2. **开发效率低**：缺乏统一指导
3. **代码审查难**：标准不统一

### 长期影响
1. **技术债务累积**：违反分层原则
2. **维护成本高**：结构混乱导致修改困难
3. **扩展性差**：新功能添加无明确位置
4. **团队协作难**：成员间理解不一致

---

## 规范改进建议

### 立即修复（高优先级）
1. **迁移技术实现**：将 `common/utils/` 和 `common/errors/` 中的技术实现移到 Infrastructure Layer
2. **清理仓储接口**：移除 `llm` 和 `tools` 中的重复接口定义
3. **统一接口位置**：将 `interfaces/` 目录内容合并到对应业务目录

### 中期优化（中优先级）
1. **拆分 common 模块**：将技术基础设施分离
2. **评估子模块**：考虑将 `threads/checkpoints` 独立为顶级模块
3. **完善简单模块**：为 `prompts` 补充必要的服务和仓储

### 长期规划（低优先级）
1. **制定详细规范**：编写领域层结构指南
2. **代码生成工具**：开发脚手架工具
3. **自动化检查**：添加架构规范检查工具

---

## 结论

当前实现基本遵循了 Domain Layer 的核心原则，但在技术实现隔离、接口统一性和结构一致性方面存在明显问题。主要违反点集中在 `common`、`llm` 和 `tools` 模块。

建议优先修复高优先级问题，确保架构规范的严格执行，然后逐步优化中低优先级问题，最终建立统一、清晰的领域层结构规范。