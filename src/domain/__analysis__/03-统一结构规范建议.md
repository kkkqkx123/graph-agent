# 统一结构规范建议

## 目标与原则

### 核心目标
1. **统一性**：所有领域模块采用一致的结构
2. **可扩展性**：支持从简单到复杂的模块演进
3. **规范性**：严格遵循DDD和架构规范
4. **实用性**：平衡规范性与开发效率

### 设计原则
1. **渐进式复杂度**：根据模块复杂度采用不同结构
2. **职责分离**：清晰界定各组件职责
3. **最小必要**：只包含必要的目录和文件
4. **约定优于配置**：提供明确的默认约定

---

## 分级结构规范

### Level 1：极简结构（Simple）

**适用场景**：
- 纯CRUD模块
- 业务逻辑简单
- 实体属性少于5个
- 无复杂业务规则

**目录结构**：
```
module-name/
├── index.ts           # 模块入口
├── entities/          # 实体定义
│   └── index.ts
└── value-objects/     # 值对象
    └── index.ts
```

**文件示例**：
```typescript
// entities/prompt.ts
export interface Prompt {
  id: PromptId
  name: string
  content: string
  status: PromptStatus
}

// value-objects/prompt-id.ts
export class PromptId extends ID {
  static create(value: string): PromptId {
    return new PromptId(value, 'prompt')
  }
}
```

**使用条件**：
- 模块功能单一
- 无复杂业务逻辑
- 不需要领域服务
- 仓储操作标准CRUD

---

### Level 2：标准结构（Standard）

**适用场景**：
- 中等复杂度业务
- 需要领域服务
- 有业务规则验证
- 需要自定义仓储方法

**目录结构**：
```
module-name/
├── index.ts           # 模块入口
├── entities/          # 实体定义
│   ├── index.ts
│   └── *.ts
├── value-objects/     # 值对象
│   ├── index.ts
│   └── *.ts
├── services/          # 领域服务
│   ├── index.ts
│   └── *.ts
└── repositories/      # 仓储接口
    ├── index.ts
    └── *.ts
```

**扩展规则**：
- 当需要业务逻辑时添加 `services/`
- 当需要自定义仓储方法时添加 `repositories/`
- 保持接口定义在对应目录中

---

### Level 3：完整结构（Complete）

**适用场景**：
- 复杂业务逻辑
- 需要事件驱动
- 多实体协作
- 状态管理复杂

**目录结构**：
```
module-name/
├── index.ts           # 模块入口
├── entities/          # 实体定义
├── value-objects/     # 值对象
├── services/          # 领域服务
├── repositories/      # 仓储接口
├── events/            # 领域事件
├── factories/         # 工厂（如需要）
└── specifications/    # 规格（如需要）
```

**可选扩展**：
- `factories/`：复杂实体创建逻辑
- `specifications/`：复杂查询规格
- `policies/`：业务策略规则

---

### Level 4：企业级结构（Enterprise）

**适用场景**：
- 核心域（Core Domain）
- 复杂状态机
- 多子域协作
- 高度可配置

**目录结构**：
```
module-name/
├── index.ts
├── entities/          # 实体
├── value-objects/     # 值对象
├── services/          # 领域服务
├── repositories/      # 仓储接口
├── events/            # 领域事件
├── factories/         # 工厂
├── specifications/    # 规格
├── policies/          # 策略
├── state/             # 状态机
├── strategies/        # 策略模式
└── sub-modules/       # 子模块（谨慎使用）
    └── sub-module-name/
```

**使用警告**：
- 子模块必须严格评估
- 优先考虑独立顶级模块
- 必须有明确的领域边界

---

## 结构选择决策树

```
模块复杂度评估
    ↓
实体数量 ≤ 3 且 业务规则 ≤ 2？
    ↓是                    ↓否
Level 1: 极简结构        需要领域服务？
                            ↓是                    ↓否
                        Level 2: 标准结构        需要事件/复杂逻辑？
                                                    ↓是                    ↓否
                                                Level 3: 完整结构        Level 2: 标准结构

是否需要子模块？
    ↓是                    ↓否
评估独立模块可能性      使用选定级别
    ↓
Level 4: 企业级结构（谨慎）
```

---

## 具体实施规范

### 1. 文件命名规范

```typescript
// 实体：使用名词，首字母大写
export class Workflow { }
export interface Prompt { }

// 值对象：使用业务名称 + 类型
export class WorkflowId extends ID { }
export class ExecutionStatus extends Enum { }

// 服务：使用动词 + 名词 + Service
export class WorkflowExecutionService { }
export class SessionManagementService { }

// 仓储：使用实体名 + Repository
export interface WorkflowRepository extends Repository<Workflow> { }

// 事件：使用过去时态 + Event
export class WorkflowCreatedEvent extends DomainEvent { }
export class StatusChangedEvent extends DomainEvent { }
```

### 2. 目录组织规范

```
// 每个目录必须有 index.ts 统一导出
entities/
├── index.ts           # 导出所有实体
├── workflow.ts        # 主实体
├── workflow-node.ts   # 相关实体
└── workflow-edge.ts   # 相关实体

// 避免深层嵌套
❌ entities/nested/deep/structure.ts
✅ entities/structure.ts

// 相关文件就近组织
✅ workflow/
    ├── entities/workflow.ts
    ├── value-objects/workflow-id.ts
    └── services/workflow-service.ts
```

### 3. 接口定义规范

```typescript
// ❌ 避免：接口分离
interfaces/
├── user-interface.ts
└── product-interface.ts

// ✅ 推荐：接口与实现就近
entities/
├── user.ts           # 包含 User 接口
└── product.ts        # 包含 Product 接口

// ❌ 避免：重复接口定义
// repository.ts
export interface UserRepository { }

// repository.interface.ts  
export interface IUserRepository { }  // 重复！

// ✅ 推荐：单一接口定义
// repository.ts
export interface UserRepository extends Repository<User> { }
```

### 4. 模块依赖规范

```typescript
// ✅ 允许：依赖 common 模块
import { ID, Entity, DomainError } from '../../common'

// ✅ 允许：模块内依赖
import { WorkflowId } from '../value-objects'
import { WorkflowRepository } from '../repositories'

// ❌ 禁止：跨模块依赖（除 common 外）
import { SessionService } from '../../sessions'  // 错误！
import { UserService } from '../../users'        // 错误！

// ⚠️ 谨慎：事件可以跨模块
import { WorkflowCreatedEvent } from '../events'  // 允许
```

---

## 迁移策略

### 阶段1：制定基准（第1周）
1. 确定当前各模块复杂度级别
2. 为每个模块选择合适结构级别
3. 创建迁移计划和时间表

### 阶段2：低风险迁移（第2-3周）
1. 从简单模块开始（prompts）
2. 整理文件命名和目录结构
3. 更新模块入口文件

### 阶段3：核心模块重构（第4-6周）
1. 重构高复杂度模块（llm, tools）
2. 清理仓储接口重复定义
3. 迁移技术实现到基础设施层

### 阶段4：验证和优化（第7-8周）
1. 运行测试确保功能正常
2. 收集团队反馈
3. 完善规范和工具

---

## 质量门禁

### 结构检查清单
- [ ] 目录结构符合选定级别
- [ ] 所有文件都有正确的命名
- [ ] 每个目录都有 index.ts 入口
- [ ] 无重复接口定义
- [ ] 无跨模块依赖（common 除外）
- [ ] 技术实现不在领域层

### 代码审查要点
1. **结构一致性**：是否符合模块级别规范
2. **职责清晰**：每个组件职责是否单一
3. **依赖正确**：是否违反分层原则
4. **命名规范**：是否遵循命名约定
5. **接口完整**：是否包含必要的方法定义

---

## 工具支持建议

### 1. 代码生成器
```bash
# 生成指定级别的模块结构
npm run generate:domain --name=user --level=standard

# 生成特定组件
npm run generate:entity --name=workflow --module=workflow
npm run generate:service --name=execution --module=workflow
```

### 2. 结构检查工具
```bash
# 检查模块结构合规性
npm run lint:domain-structure

# 检查命名规范
npm run lint:naming-convention

# 检查依赖关系
npm run lint:dependencies
```

### 3. 文档生成器
```bash
# 生成模块结构文档
npm run docs:domain-structure

# 生成依赖图
npm run docs:dependency-graph
```

---

## 实施建议

### 短期（1个月内）
1. **制定团队规范**：与团队讨论确定最终规范
2. **选择试点模块**：从简单模块开始试点
3. **建立检查机制**：添加代码审查检查项

### 中期（1-3个月）
1. **逐步迁移**：按计划重构现有模块
2. **完善工具**：开发必要的脚手架工具
3. **培训团队**：组织规范培训

### 长期（3个月后）
1. **自动化检查**：集成到CI/CD流程
2. **持续优化**：根据实践调整规范
3. **经验总结**：形成最佳实践文档

---

## 风险评估与应对

### 主要风险
1. **迁移成本高**：现有代码重构工作量大
2. **团队阻力**：改变现有开发习惯
3. **短期效率下降**：开发速度可能降低
4. **规范过于严格**：可能抑制创新

### 应对措施
1. **渐进式迁移**：避免一次性大规模重构
2. **充分沟通**：解释规范的价值和必要性
3. **工具支持**：提供自动化工具减少手工工作
4. **灵活调整**：根据反馈及时调整规范
5. **培训支持**：提供充分的培训和指导

---

## 成功标准

### 量化指标
- 结构一致性：>95% 模块符合规范
- 代码审查效率：提升 30%
- 新成员上手时间：减少 50%
- 缺陷率：降低 20%

### 定性指标
- 代码可读性显著提升
- 模块职责更加清晰
- 团队协作更加顺畅
- 架构演进更加容易

通过实施统一结构规范，将显著提升代码质量、降低维护成本，并为框架的长期发展奠定坚实基础。